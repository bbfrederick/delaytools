#!/usr/bin/env python
# -*- coding: latin-1 -*-
#
#   Copyright 2016-2019 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
#       $Author: frederic $
#       $Date: 2016/06/14 12:04:50 $
#       $Id: histnifti,v 1.8 2016/06/14 12:04:50 frederic Exp $
#
from __future__ import print_function
import rapidtide.io as tide_io
import rapidtide.stats as tide_stats
import argparse
import sys
import numpy as np
import rapidtide.workflows.parser_funcs as pf


def progressbar(thisval, end_val, label="Percent", barsize=60):
    percent = float(thisval) / end_val
    hashes = "#" * int(round(percent * barsize))
    spaces = " " * (barsize - len(hashes))
    sys.stdout.write("\r{0}: [{1}] {2:.3f}%".format(label, hashes + spaces, 100.0 * percent))
    sys.stdout.flush()


def _get_parser():
    # get the command line parameters
    parser = argparse.ArgumentParser(
        prog="histnifti",
        description="Generates a histogram of the values in a NIFTI file.",
        usage="%(prog)s inputfile outputroot",
    )
    parser.add_argument("inputfile", help="the name of the input NIFTI file")
    parser.add_argument("outputroot", help="the root of the output file names")
    parser.add_argument(
        "--histlen",
        dest="histlen",
        type=int,
        metavar="LEN",
        help="Set histogram length to LEN (default is 101).",
        default=101,
    )
    parser.add_argument(
        "--minval",
        dest="minval",
        action="store",
        type=lambda x: pf.is_float(parser, x),
        metavar="MINVAL",
        help="Minimum bin value in histogram.",
        default=None,
    )
    parser.add_argument(
        "--maxval",
        dest="maxval",
        action="store",
        type=lambda x: pf.is_float(parser, x),
        metavar="MAXVAL",
        help="Maximum bin value in histogram.",
        default=None,
    )
    parser.add_argument(
        "--robustrange",
        dest="robustrange",
        action="store_true",
        help=("Set histogram limits to the data's robust range (2nd to 98th percentile)."),
        default=False,
    )
    parser.add_argument(
        "--maskfile",
        dest="maskfile",
        type=str,
        metavar="MASK",
        help="Only process voxels within the 3D mask MASK.",
        default=None,
    )
    return parser


def main():
    # set default variable values
    thepercentiles = [0.95, 0.99, 0.995, 0.999]
    thepvalnames = []
    for thispercentile in thepercentiles:
        thepvalnames.append(str(1.0 - thispercentile).replace(".", "p"))

    # get the command line parameters
    try:
        args = _get_parser().parse_args()
    except SystemExit:
        _get_parser().print_help()
        raise

    # load the data
    print("loading data")
    input_img, input_data, input_hdr, thedims, thesizes = tide_io.readfromnifti(args.inputfile)
    xsize, ysize, numslices, timepoints = tide_io.parseniftidims(thedims)
    if timepoints > 1:
        is4D = True
    else:
        is4D = False

    if args.maskfile is not None:
        (
            mask_img,
            mask_data,
            mask_hdr,
            themaskdims,
            themasksizes,
        ) = tide_io.readfromnifti(args.maskfile)
        if not tide_io.checkspacematch(mask_hdr, input_hdr):
            print("Dimensions of " + args.maskfile + " mask do not match the input data - exiting")
            sys.exit()
    else:
        mask_data = np.ones((xsize, ysize, numslices), dtype=np.float64)

    numspatiallocs = int(xsize) * int(ysize) * int(numslices)
    maskasmatrix = mask_data.reshape((numspatiallocs))
    validvoxels = np.where(maskasmatrix > 0)[0]
    numvalidvoxels = len(validvoxels)

    if is4D:
        dataasmatrix = input_data.reshape((numspatiallocs, timepoints))
        validdata = dataasmatrix[validvoxels, :]
    else:
        dataasmatrix = input_data.reshape((numspatiallocs))
        validdata = dataasmatrix[validvoxels]

    # set the histogram range
    if args.robustrange:
        histmin, histmax = tide_stats.getfracvals(validdata, [0.02, 0.98], numbins=101)[0]
    else:
        if args.minval is None:
            histmin = np.min(validdata)
        else:
            histmin = args.minval
        if args.maxval is None:
            histmax = np.max(validdata)
        else:
            histmax = args.maxval
    therange = (histmin, histmax)
    print("the range is ", therange)

    if is4D:
        print("allocating arrays")
        sorteddata = np.zeros((numvalidvoxels, timepoints), dtype="float")
        outputhists = np.zeros((numspatiallocs, args.histlen), dtype="float")
        outputhistfits = np.zeros((numspatiallocs, args.histlen), dtype="float")
        pcts_data = np.zeros((numspatiallocs, len(thepercentiles)), dtype="float")
        pcts_fit = np.zeros((numspatiallocs, len(thepercentiles)), dtype="float")

        # cycle over all voxels
        print("now cycling over all voxels")
        for spatialloc in range(0, validvoxels):
            meanhist, bins = np.histogram(
                validdata[spatialloc, :], bins=numbins, range=(histmin, histmax)
            )
            sorteddata[spatialloc, :] = np.sort(dataasmatrix[spatialloc, :])
            if spatialloc % 100 == 0:
                progressbar(spatialloc + 1, numspatiallocs, label="Percent complete")

        # now do the ones with other numbers of time points
        theheader = input_hdr
        tide_io.savetonifti(
            sorteddata.reshape((xsize, ysize, numslices, timepoints)),
            theheader,
            args.outputroot + "_sorted",
        )
    else:
        dataasmatrix = input_data.reshape((numspatiallocs))
        validdata = dataasmatrix[validvoxels]
        tide_stats.makeandsavehistogram(
            validdata,
            args.histlen,
            0,
            args.outputroot + "_hist",
            displaytitle="Value histogram",
            displayplots=True,
            refine=False,
        )


if __name__ == "__main__":
    main()
